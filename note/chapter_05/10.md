# 原生deno实现稳定HTTP服务

## 前言

在上上上一篇文章[原生deno实现简单HTTP服务](https://github.com/chenshenhai/deno_note/blob/master/note/chapter_05/07.md) 结尾中，可以看出简单用`deno`的原生`TCP`服务直接处理`HTTP`请求响应，在`TCP`对话频繁建立
过程中，导致`TCP`对话读写时机混乱或者不对等，出现以下问题。

![http_err_2](https://user-images.githubusercontent.com/8216630/52639578-89894380-2f0f-11e9-8e52-592f31b15d01.jpg)

本章将基于 [原生deno实现简单HTTP服务](https://github.com/chenshenhai/deno_note/blob/master/note/chapter_05/07.md) 的原理，结合前面两章 [原生deno处理HTTP请求](https://github.com/chenshenhai/deno_note/blob/master/note/chapter_05/08.md)和[原生deno处理HTTP响应](https://github.com/chenshenhai/deno_note/blob/master/note/chapter_05/09.md) 所实现的能力，打造一个排队机制来控制`HTTP`服务里的`TCP`对话控制。

本来一开始没头绪的，但是后来参考了官方标准模块 [deno/deno_std/http/server.ts](https://github.com/denoland/deno_std/blob/master/http/server.ts) 的实现。发现官方也是利用比较“巧妙”的方式来控制`TCP`频繁对话控制，在此思想上做了调整，实现了一个比较健壮的`HTTP`服务器。


## 实现原理

- 初始化`TCP`服务
- 等待接收`TCP`对话
- 接收到`TCP`对话后，进行请求报文读取
- 如果没读取异常，就把对话存入队列，等待下一个对话读取和进入队列。
    - 如果读取异常就捕获同时关闭对话
- 等待执行完对话队列的响应完毕后，就进入下一次`TCP`对话的接收

## 具体实现

### 具体代码地址

### 具体代码讲解

## 测试

### 基准测试

### 单元测试